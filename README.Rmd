---
output_format: github_document
---

# fastcooc: Fast pairwise computation of species associations 

<!-- 
rmarkdown::render('./README.Rmd', output_format = "github_document")
-->

```{r setup, echo = FALSE, display = FALSE}
library(devtools)
document()
clean_dll()
load_all()
```

This small package provides an implementation of the procedure presented by 
Veech (2013) to build association networks from presence/absence data (also 
named co-occurrence networks). It is aimed to be much faster than the 
implementation in the package *cooccur* for situations with a high number of 
species, and low number of sites. 

The speed of the implementation relies on pre-computing P-values and storing 
them in a lookup table. A fast compiled function then loops through all pairs of 
species, computes their co-occurrence and total abundances, then looks up the 
P-value in the precomputed table. 

Depending on your number of sites and number of species, pre-computing this 
table can take a while, but this needs only to be done once and can be repeated 
on different datasets as long as the number of sites in the analysis does not 
change. 

A typical workflow looks like this: 

```{r workflow}

# Load a community matrix from the vegan package
library(vegan)
data(dune)
dune_pa <- dune > 0 # Transform to presence/absence data

# Compute associations
Nsites <- nrow(dune_pa)
pval_table <- precompute_pvalues(Nsites, ntries = 9999)
coocs <- fastcooc(dune_pa, pval_array = pval_table)

# Display pairwise species associations
library(ggplot2)
ggplot(coocs) + 
  geom_raster(aes(x = sp1, y = sp2, 
                  fill = ifelse(pval < 0.5, "negative assoc.", 
                                "positive assoc."))) + 
  scale_fill_manual(values = c('blue', 'red'), name = "Associations") + 
  coord_fixed() + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, vjust = .5, hjust = 1))

```

Here are some graphs to help you choose: 

```{r}
naive_cooc <- function(sites, trim_threshold = 0.05) { 
  pmat <- matrix(NA_real_, ncol(sites), ncol(sites))
  for (spi in seq.int(nrow(pmat))) { 
    for (spj in seq.int(nrow(pmat))) { 
      if ( sd(sites[ ,spi]) != 0 && 
           sd(sites[ ,spj]) != 0 ) { 
        pmat[spi, spj] <- coocvec(sites[ ,spi], sites[ ,spj], ntries = 999)[4]
      } else { 
        pmat[spi, spj] <- 0.5
      }
    }
  }
  
  spnames <- seq.int(ncol(pmat))
  cooc_results <- data.frame(expand.grid(sp1 = spnames, 
                                         sp2 = spnames), 
                             pval = as.vector(pmat))
  cooc_results <- subset(cooc_results, 
                          pmin(pval, 1 - pval) < (trim_threshold/2))

  cooc_results
}
```

```{r sites_timings}

make_one_benchmark <- function(nsp, nsites) { 
  bigmat <- matrix(rnorm(nsites*nsp), nrow = nsites, ncol = nsp) > 0
  
  a <- system.time({ 
      result <- fastcooc(bigmat, long_form = TRUE, trim_threshold = 0.05, 
                         ntries = 99) %>% 
      subset(sp1 < sp2)
  })
  
  b <- system.time({ 
    cooccurdf <- print(cooccur::cooccur(t(bigmat), prob = "hyper")) %>% 
                   (function(df) df[ c('sp1', 'sp2')]) %>% 
                   as.matrix() 
  })
  
  d <- system.time({ 
      naive_cooc(bigmat)
    })
  
  all_inters_fc <- sort(paste(result[ ,'sp1'], result[ ,'sp2'], sep = '-'))
  all_inters_co <- sort(paste(cooccurdf[ ,'sp1'], cooccurdf[ ,'sp2'], sep = "-"))
  
  n_in_common <- length(intersect(all_inters_co, all_inters_fc))
  n_diff <- max(length(all_inters_co), length(all_inters_fc)) - n_in_common
  ntot <- nsp*(nsp-1)/2
  
  data.frame(n_in_common = n_in_common, 
             n_diff = n_diff, 
             ntot = ntot, 
             nsp = nsp, 
             nsites = nsites, 
             fastcooc = a['elapsed'], 
             cooccur  = b['elapsed'], 
             without_lut = d['elapsed'])
}

benchmarks <- expand.grid(nsp    = seq(5, 250, l = 3), 
                          nsites = seq(5, 20,  l = 3))

bench_results <- plyr::ddply(benchmarks, ~ nsp + nsites, with, 
                             make_one_benchmark(nsp, nsites))


library(ggplot2)
library(tidyr)
ggplot(gather(bench_results, method, elapsed, fastcooc, 
              cooccur, without_lut), 
       aes(x = nsites, y = elapsed, color = method) ) + 
  geom_line(aes(group = nsp)) + 
  geom_point() + 
  scale_y_continuous(trans = "log", 
                     breaks = unique(as.vector(outer(c(1, 2, 5, 10), 10^seq(-2, 3))))) + 
  theme_minimal() + 
  labs(x = "Number of sites (100 species)", 
       y = "Time elapsed (in seconds)")

ggplot(gather(bench_results, method, elapsed, fastcooc, 
              cooccur, without_lut), 
       aes(x = nsites, y = nsp, fill = elapsed) ) + 
  geom_raster() + 
  theme_minimal() + 
  facet_grid( ~ method ) + 
  labs(x = "Number of sites", 
       y = "Number of species", 
       caption = "Color indicate the time elapsed")

bench_results %>% 
  plyr::mutate(fastcooc_relative = fastcooc / without_lut) %>% 
  plyr::mutate(fastcooc_relative = ifelse(fastcooc_relative > 1, 
                                          NA, log10(fastcooc_relative))) %>% 
  ggplot(aes(x = nsites, y = nsp, fill = fastcooc_relative) ) + 
    geom_raster() + 
    theme_minimal() + 
    labs(x = "Number of sites", 
         y = "Number of species", 
         caption = "Color indicate the time elapsed")

```

# Notes

* This package has been tested againts the *coocurr* package to check that it 
produces good results. However, results can still be slightly different because 
it uses a randomization-based procedure to compute P-values instead of an 
analytical approach. Typically, expect xx-yy% of links to be different. 

* This package does not handle NAs in data, but does handle species that are 
completely absent or always present (those for which P-values cannot be 
computed), by assuming they cannot form significant associations. 

* This package does not compute any form of association strength 
(odd ratio, variance ratio, standardized effect size, etc.), and just reports 
P-values, which is the only information needed to build association networks. 


